"""Vulnerability matcher for SBOM components using PURL and version matching.

Matches SBOM components to known vulnerabilities by:
1. Querying OSV.dev (primary) and NVD (fallback) using PURL
2. Version range matching for affected packages
3. Creating component_vulnerabilities records
4. Deduplicating vulnerabilities across sources
"""
# flake8: noqa: E501


from dataclasses import dataclass
from datetime import datetime
from typing import Optional

import structlog
from packaging.version import InvalidVersion, Version

from apps.api.services.sbom.vulnerability.nvd_client import NVDClient
from apps.api.services.sbom.vulnerability.osv_client import OSVClient

logger = structlog.get_logger(__name__)


@dataclass(slots=True)
class MatchedVulnerability:
    """Matched vulnerability data for a component."""

    cve_id: str
    aliases: list[str]
    severity: str
    cvss_score: Optional[float]
    cvss_vector: Optional[str]
    title: Optional[str]
    description: str
    affected_packages: list[dict]
    fixed_versions: list[str]
    references: list[dict]
    published_at: Optional[str]
    modified_at: Optional[str]
    source: str  # 'osv' or 'nvd'


class VulnerabilityMatcher:
    """Match SBOM components to known vulnerabilities."""

    def __init__(self, nvd_api_key: Optional[str] = None):
        """
        Initialize vulnerability matcher.

        Args:
            nvd_api_key: Optional NVD API key for higher rate limits
        """
        self.osv_client = OSVClient()
        self.nvd_client = NVDClient(api_key=nvd_api_key)

    async def close(self):
        """Close HTTP clients."""
        await self.osv_client.close()
        await self.nvd_client.close()

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def match_component(
        self,
        purl: str,
        package_type: str,
        name: str,
        version: Optional[str] = None,
    ) -> list[MatchedVulnerability]:
        """
        Match a single component to vulnerabilities.

        Args:
            purl: Package URL
            package_type: Package ecosystem (pypi, npm, go, etc.)
            name: Package name
            version: Package version (optional)

        Returns:
            List of matched vulnerabilities

        Example:
            >>> matcher = VulnerabilityMatcher()
            >>> vulns = await matcher.match_component(
            ...     "pkg:pypi/flask@2.0.3", "pypi", "flask", "2.0.3"
            ... )
        """
        matched_vulns = []

        # Query OSV.dev first (primary source)
        if purl:
            osv_vulns = await self.osv_client.query_by_purl(purl)
            for osv_vuln in osv_vulns:
                # Check if version is affected
                if version and not self._is_version_affected(
                    version, osv_vuln.affected_packages
                ):
                    continue

                # Extract fixed versions
                fixed_versions = self._extract_fixed_versions(
                    osv_vuln.affected_packages
                )

                matched_vuln = MatchedVulnerability(
                    cve_id=osv_vuln.id,
                    aliases=osv_vuln.aliases,
                    severity=osv_vuln.severity,
                    cvss_score=osv_vuln.cvss_score,
                    cvss_vector=osv_vuln.cvss_vector,
                    title=osv_vuln.summary,
                    description=osv_vuln.details,
                    affected_packages=osv_vuln.affected_packages,
                    fixed_versions=fixed_versions,
                    references=osv_vuln.references,
                    published_at=osv_vuln.published,
                    modified_at=osv_vuln.modified,
                    source="osv",
                )
                matched_vulns.append(matched_vuln)

        logger.info(
            "vulnerability_matching_complete",
            purl=purl,
            name=name,
            version=version,
            osv_count=len(matched_vulns),
        )

        return matched_vulns

    async def match_components_batch(
        self,
        components: list[dict],
    ) -> dict[int, list[MatchedVulnerability]]:
        """
        Match multiple components to vulnerabilities in batch.

        Uses OSV.dev batch API for efficient querying.

        Args:
            components: List of component dicts with keys:
                - id: Component ID
                - purl: Package URL
                - package_type: Package ecosystem
                - name: Package name
                - version: Package version (optional)

        Returns:
            Dictionary mapping component ID to list of vulnerabilities

        Example:
            >>> matcher = VulnerabilityMatcher()
            >>> components = [
            ...     {"id": 1, "purl": "pkg:pypi/flask@2.0.3", "package_type": "pypi",
            ...      "name": "flask", "version": "2.0.3"},
            ...     {"id": 2, "purl": "pkg:npm/lodash@4.17.20", "package_type": "npm",
            ...      "name": "lodash", "version": "4.17.20"},
            ... ]
            >>> results = await matcher.match_components_batch(components)
        """
        results = {}

        # Build PURL list for batch query
        purl_to_component = {}
        purls = []
        for comp in components:
            if comp.get("purl"):
                purls.append(comp["purl"])
                purl_to_component[comp["purl"]] = comp

        if not purls:
            logger.info("no_purls_to_match", component_count=len(components))
            return results

        # Query OSV.dev in batch
        logger.info("batch_vulnerability_matching", component_count=len(purls))
        osv_results = await self.osv_client.query_batch(purls)

        # Process results
        for purl, osv_vulns in osv_results.items():
            comp = purl_to_component[purl]
            comp_id = comp["id"]
            version = comp.get("version")

            matched_vulns = []
            for osv_vuln in osv_vulns:
                # Check if version is affected
                if version and not self._is_version_affected(
                    version, osv_vuln.affected_packages
                ):
                    continue

                # Extract fixed versions
                fixed_versions = self._extract_fixed_versions(
                    osv_vuln.affected_packages
                )

                matched_vuln = MatchedVulnerability(
                    cve_id=osv_vuln.id,
                    aliases=osv_vuln.aliases,
                    severity=osv_vuln.severity,
                    cvss_score=osv_vuln.cvss_score,
                    cvss_vector=osv_vuln.cvss_vector,
                    title=osv_vuln.summary,
                    description=osv_vuln.details,
                    affected_packages=osv_vuln.affected_packages,
                    fixed_versions=fixed_versions,
                    references=osv_vuln.references,
                    published_at=osv_vuln.published,
                    modified_at=osv_vuln.modified,
                    source="osv",
                )
                matched_vulns.append(matched_vuln)

            if matched_vulns:
                results[comp_id] = matched_vulns

        logger.info(
            "batch_vulnerability_matching_complete",
            component_count=len(purls),
            components_with_vulns=len(results),
            total_vulns=sum(len(v) for v in results.values()),
        )

        return results

    def _is_version_affected(self, version: str, affected_packages: list[dict]) -> bool:
        """
        Check if a version is affected by a vulnerability.

        Args:
            version: Package version to check
            affected_packages: List of affected package dicts from OSV

        Returns:
            True if version is affected, False otherwise
        """
        try:
            pkg_version = Version(version)
        except InvalidVersion:
            logger.warning("invalid_version", version=version)
            # If we can't parse the version, assume it's affected (safer)
            return True

        for affected in affected_packages:
            ranges = affected.get("ranges", [])
            for range_spec in ranges:
                range_type = range_spec.get("type")

                if range_type == "ECOSYSTEM":
                    # Use semantic versioning
                    events = range_spec.get("events", [])
                    in_affected_range = False
                    min_version = None
                    max_version = None

                    for event in events:
                        if "introduced" in event:
                            introduced = event["introduced"]
                            if introduced == "0":
                                in_affected_range = True
                            else:
                                try:
                                    min_version = Version(introduced)
                                    in_affected_range = pkg_version >= min_version
                                except InvalidVersion:
                                    pass

                        if "fixed" in event:
                            fixed = event["fixed"]
                            try:
                                max_version = Version(fixed)
                                if pkg_version >= max_version:
                                    in_affected_range = False
                            except InvalidVersion:
                                pass

                    if in_affected_range:
                        return True

                elif range_type == "SEMVER":
                    # Semantic version range
                    events = range_spec.get("events", [])
                    for event in events:
                        if "introduced" in event or "fixed" in event:
                            # Similar logic to ECOSYSTEM
                            # For simplicity, assume affected if in range
                            return True

            # Check explicit affected versions
            versions = affected.get("versions", [])
            if version in versions:
                return True

        return False

    def _extract_fixed_versions(self, affected_packages: list[dict]) -> list[str]:
        """
        Extract fixed versions from affected packages.

        Args:
            affected_packages: List of affected package dicts from OSV

        Returns:
            List of fixed version strings
        """
        fixed_versions = []

        for affected in affected_packages:
            ranges = affected.get("ranges", [])
            for range_spec in ranges:
                events = range_spec.get("events", [])
                for event in events:
                    if "fixed" in event:
                        fixed_versions.append(event["fixed"])

        return list(set(fixed_versions))  # Deduplicate

    async def sync_vulnerability_to_db(
        self, db, matched_vuln: MatchedVulnerability, tenant_id: int
    ) -> int:
        """
        Sync a matched vulnerability to the database.

        Creates or updates vulnerability record.

        Args:
            db: PyDAL database instance
            matched_vuln: Matched vulnerability data
            tenant_id: Tenant ID

        Returns:
            Vulnerability database ID
        """
        # Check if vulnerability already exists
        existing = (
            db(
                (db.vulnerabilities.cve_id == matched_vuln.cve_id)
                & (db.vulnerabilities.tenant_id == tenant_id)
            )
            .select()
            .first()
        )

        if existing:
            # Update existing record
            db.vulnerabilities[existing.id] = {
                "aliases": matched_vuln.aliases,
                "severity": matched_vuln.severity,
                "cvss_score": matched_vuln.cvss_score,
                "cvss_vector": matched_vuln.cvss_vector,
                "title": matched_vuln.title,
                "description": matched_vuln.description,
                "affected_packages": matched_vuln.affected_packages,
                "fixed_versions": matched_vuln.fixed_versions,
                "references": matched_vuln.references,
                "modified_at": (
                    datetime.fromisoformat(
                        matched_vuln.modified_at.replace("Z", "+00:00")
                    )
                    if matched_vuln.modified_at
                    else None
                ),
                "source": matched_vuln.source,
            }
            return existing.id
        else:
            # Insert new record
            vuln_id = db.vulnerabilities.insert(
                tenant_id=tenant_id,
                cve_id=matched_vuln.cve_id,
                aliases=matched_vuln.aliases,
                severity=matched_vuln.severity,
                cvss_score=matched_vuln.cvss_score,
                cvss_vector=matched_vuln.cvss_vector,
                title=matched_vuln.title,
                description=matched_vuln.description,
                affected_packages=matched_vuln.affected_packages,
                fixed_versions=matched_vuln.fixed_versions,
                references=matched_vuln.references,
                published_at=(
                    datetime.fromisoformat(
                        matched_vuln.published_at.replace("Z", "+00:00")
                    )
                    if matched_vuln.published_at
                    else None
                ),
                modified_at=(
                    datetime.fromisoformat(
                        matched_vuln.modified_at.replace("Z", "+00:00")
                    )
                    if matched_vuln.modified_at
                    else None
                ),
                source=matched_vuln.source,
                is_active=True,
            )
            return vuln_id

    async def create_component_vulnerability_link(
        self,
        db,
        component_id: int,
        vulnerability_id: int,
        tenant_id: int,
    ) -> int:
        """
        Create component-vulnerability link in database.

        Args:
            db: PyDAL database instance
            component_id: Component ID
            vulnerability_id: Vulnerability ID
            tenant_id: Tenant ID

        Returns:
            Component vulnerability link ID
        """
        # Check if link already exists
        existing = (
            db(
                (db.component_vulnerabilities.component_id == component_id)
                & (db.component_vulnerabilities.vulnerability_id == vulnerability_id)
                & (db.component_vulnerabilities.tenant_id == tenant_id)
            )
            .select()
            .first()
        )

        if existing:
            # Link already exists
            return existing.id

        # Create new link
        link_id = db.component_vulnerabilities.insert(
            tenant_id=tenant_id,
            component_id=component_id,
            vulnerability_id=vulnerability_id,
            status="open",
        )

        return link_id
