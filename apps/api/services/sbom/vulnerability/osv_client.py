"""OSV.dev API client for vulnerability data retrieval.

OSV.dev provides a comprehensive, open-source vulnerability database with:
- Free, unlimited API access
- Batch query endpoint for efficient lookups
- Coverage across multiple ecosystems (PyPI, npm, Go, Maven, etc.)
- PURL (Package URL) support for standardized package identification

API Documentation: https://osv.dev/docs/
"""

from dataclasses import dataclass
from typing import Optional

import httpx
import structlog

logger = structlog.get_logger(__name__)

OSV_API_BASE = "https://api.osv.dev/v1"
OSV_BATCH_ENDPOINT = f"{OSV_API_BASE}/querybatch"
OSV_QUERY_ENDPOINT = f"{OSV_API_BASE}/query"

# Package ecosystem mapping to OSV ecosystem names
ECOSYSTEM_MAP = {
    "pypi": "PyPI",
    "npm": "npm",
    "go": "Go",
    "maven": "Maven",
    "nuget": "NuGet",
    "cargo": "crates.io",
    "gem": "RubyGems",
}


@dataclass(slots=True)
class OSVVulnerability:
    """OSV vulnerability data structure."""

    id: str  # CVE-2024-12345 or GHSA-xxxx-xxxx-xxxx
    aliases: list[str]
    summary: str
    details: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    cvss_score: Optional[float]
    cvss_vector: Optional[str]
    affected_packages: list[dict]
    references: list[dict]
    published: str
    modified: str


class OSVClient:
    """Client for querying OSV.dev vulnerability database."""

    def __init__(self, timeout: int = 30):
        """
        Initialize OSV client.

        Args:
            timeout: Request timeout in seconds
        """
        self.timeout = timeout
        self.client = httpx.AsyncClient(timeout=timeout)

    async def close(self):
        """Close HTTP client."""
        await self.client.aclose()

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def query_by_purl(self, purl: str) -> list[OSVVulnerability]:
        """
        Query vulnerabilities by Package URL (PURL).

        Args:
            purl: Package URL (e.g., pkg:pypi/flask@2.0.3)

        Returns:
            List of OSVVulnerability objects

        Example:
            >>> client = OSVClient()
            >>> vulns = await client.query_by_purl("pkg:pypi/flask@2.0.3")
        """
        try:
            payload = {"package": {"purl": purl}}

            logger.debug("osv_query_by_purl", purl=purl)

            response = await self.client.post(OSV_QUERY_ENDPOINT, json=payload)
            response.raise_for_status()

            data = response.json()
            vulns = data.get("vulns", [])

            logger.info("osv_query_complete", purl=purl, count=len(vulns))

            return [self._parse_vulnerability(v) for v in vulns]

        except httpx.HTTPStatusError as e:
            logger.error(
                "osv_query_failed",
                purl=purl,
                status=e.response.status_code,
                error=str(e),
            )
            return []
        except Exception as e:
            logger.error("osv_query_exception", purl=purl, error=str(e))
            return []

    async def query_batch(
        self, purls: list[str], batch_size: int = 1000
    ) -> dict[str, list[OSVVulnerability]]:
        """
        Query vulnerabilities for multiple PURLs in batch.

        OSV.dev batch endpoint supports up to 1000 queries per request.
        This method automatically splits larger batches.

        Args:
            purls: List of Package URLs
            batch_size: Maximum queries per batch (default: 1000)

        Returns:
            Dictionary mapping PURL to list of vulnerabilities

        Example:
            >>> client = OSVClient()
            >>> purls = ["pkg:pypi/flask@2.0.3", "pkg:npm/lodash@4.17.20"]
            >>> results = await client.query_batch(purls)
        """
        results = {}

        # Split into batches of batch_size
        for i in range(0, len(purls), batch_size):
            batch = purls[i : i + batch_size]
            batch_results = await self._query_batch_single(batch)
            results.update(batch_results)

        return results

    async def _query_batch_single(
        self, purls: list[str]
    ) -> dict[str, list[OSVVulnerability]]:
        """
        Execute a single batch query (up to 1000 PURLs).

        Args:
            purls: List of Package URLs (max 1000)

        Returns:
            Dictionary mapping PURL to list of vulnerabilities
        """
        try:
            # Build batch query payload
            queries = [{"package": {"purl": purl}} for purl in purls]
            payload = {"queries": queries}

            logger.debug("osv_batch_query", count=len(purls))

            response = await self.client.post(OSV_BATCH_ENDPOINT, json=payload)
            response.raise_for_status()

            data = response.json()
            results_list = data.get("results", [])

            # Map results back to PURLs
            results = {}
            for i, result in enumerate(results_list):
                purl = purls[i]
                vulns = result.get("vulns", [])
                results[purl] = [self._parse_vulnerability(v) for v in vulns]

            logger.info(
                "osv_batch_complete",
                count=len(purls),
                vulns_found=sum(len(v) for v in results.values()),
            )

            return results

        except httpx.HTTPStatusError as e:
            logger.error(
                "osv_batch_failed",
                count=len(purls),
                status=e.response.status_code,
                error=str(e),
            )
            return {purl: [] for purl in purls}
        except Exception as e:
            logger.error("osv_batch_exception", count=len(purls), error=str(e))
            return {purl: [] for purl in purls}

    async def query_by_package(
        self, ecosystem: str, name: str, version: Optional[str] = None
    ) -> list[OSVVulnerability]:
        """
        Query vulnerabilities by package ecosystem, name, and version.

        Args:
            ecosystem: Package ecosystem (pypi, npm, go, maven, etc.)
            name: Package name
            version: Package version (optional)

        Returns:
            List of OSVVulnerability objects

        Example:
            >>> client = OSVClient()
            >>> vulns = await client.query_by_package("pypi", "flask", "2.0.3")
        """
        try:
            # Map ecosystem to OSV ecosystem name
            osv_ecosystem = ECOSYSTEM_MAP.get(ecosystem.lower(), ecosystem)

            payload = {"package": {"ecosystem": osv_ecosystem, "name": name}}

            if version:
                payload["version"] = version

            logger.debug(
                "osv_query_by_package",
                ecosystem=osv_ecosystem,
                name=name,
                version=version,
            )

            response = await self.client.post(OSV_QUERY_ENDPOINT, json=payload)
            response.raise_for_status()

            data = response.json()
            vulns = data.get("vulns", [])

            logger.info(
                "osv_query_package_complete",
                ecosystem=osv_ecosystem,
                name=name,
                version=version,
                count=len(vulns),
            )

            return [self._parse_vulnerability(v) for v in vulns]

        except httpx.HTTPStatusError as e:
            logger.error(
                "osv_query_package_failed",
                ecosystem=ecosystem,
                name=name,
                status=e.response.status_code,
                error=str(e),
            )
            return []
        except Exception as e:
            logger.error(
                "osv_query_package_exception",
                ecosystem=ecosystem,
                name=name,
                error=str(e),
            )
            return []

    def _parse_vulnerability(self, vuln_data: dict) -> OSVVulnerability:
        """
        Parse OSV API response into OSVVulnerability object.

        Args:
            vuln_data: Raw vulnerability data from OSV API

        Returns:
            Parsed OSVVulnerability object
        """
        vuln_id = vuln_data.get("id", "UNKNOWN")
        aliases = vuln_data.get("aliases", [])
        summary = vuln_data.get("summary", "")
        details = vuln_data.get("details", "")

        # Extract severity from database_specific or severity field
        severity = "UNKNOWN"
        cvss_score = None
        cvss_vector = None

        # Try to get severity from severity field (newer format)
        severity_list = vuln_data.get("severity", [])
        if severity_list:
            for sev in severity_list:
                if sev.get("type") == "CVSS_V3":
                    cvss_vector = sev.get("score")
                    # Extract score from CVSS vector (e.g., "CVSS:3.1/AV:N/AC:L...")
                    if cvss_vector and "/" in cvss_vector:
                        try:
                            # Some APIs include score in different format
                            score_str = cvss_vector.split("/")[0].split(":")[-1]
                            cvss_score = float(score_str)
                        except (ValueError, IndexError):
                            pass

        # Determine severity level from CVSS score
        if cvss_score:
            if cvss_score >= 9.0:
                severity = "CRITICAL"
            elif cvss_score >= 7.0:
                severity = "HIGH"
            elif cvss_score >= 4.0:
                severity = "MEDIUM"
            else:
                severity = "LOW"

        # Fallback: check database_specific field
        if severity == "UNKNOWN":
            db_specific = vuln_data.get("database_specific", {})
            severity = db_specific.get("severity", "UNKNOWN").upper()

        # Extract affected packages
        affected_packages = []
        for affected in vuln_data.get("affected", []):
            package = affected.get("package", {})
            ranges = affected.get("ranges", [])
            versions = affected.get("versions", [])

            affected_packages.append(
                {
                    "ecosystem": package.get("ecosystem"),
                    "name": package.get("name"),
                    "purl": package.get("purl"),
                    "ranges": ranges,
                    "versions": versions,
                }
            )

        # Extract references
        references = []
        for ref in vuln_data.get("references", []):
            references.append({"type": ref.get("type"), "url": ref.get("url")})

        return OSVVulnerability(
            id=vuln_id,
            aliases=aliases,
            summary=summary,
            details=details,
            severity=severity,
            cvss_score=cvss_score,
            cvss_vector=cvss_vector,
            affected_packages=affected_packages,
            references=references,
            published=vuln_data.get("published", ""),
            modified=vuln_data.get("modified", ""),
        )
